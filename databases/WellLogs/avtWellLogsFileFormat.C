/*****************************************************************************
*
* Copyright (c) 2000 - 2013, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//                            avtWellLogsFileFormat.C                           //
// ************************************************************************* //

#include <avtWellLogsFileFormat.h>

#include <string>
#include <fstream>
#include <iostream>
#include <iomanip>
#include <map>

#include <vtkFloatArray.h>
#include <vtkRectilinearGrid.h>
#include <vtkStructuredGrid.h>
#include <vtkUnstructuredGrid.h>
#include <vtkCellType.h>

#include <avtDatabaseMetaData.h>
#include <avtMaterial.h>

#include <DBOptionsAttributes.h>
#include <Expression.h>

#include <InvalidVariableException.h>
#include <InvalidFilesException.h>


using     std::string;


// ****************************************************************************
//  Method: avtWellLogsFileFormat constructor
//
//  Programmer: hari -- generated by xml2avt
//  Creation:   Fri Apr 11 23:22:06 PST 2014
//
// ****************************************************************************

avtWellLogsFileFormat::avtWellLogsFileFormat(const char *filename)
    : avtSTSDFileFormat(filename)
{
    wlFilename = filename;
    haveReadFile = false;
}


// ****************************************************************************
//  Method: avtWellLogsFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: hari -- generated by xml2avt
//  Creation:   Fri Apr 11 23:22:06 PST 2014
//
// ****************************************************************************

void
avtWellLogsFileFormat::FreeUpResources(void)
{
    X.clear();
    Y.clear();
    Z1.clear();
    Z2.clear();
    haveReadFile = false;
}


// ****************************************************************************
//  Method: avtWellLogsFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: hari -- generated by xml2avt
//  Creation:   Fri Apr 11 23:22:06 PST 2014
//
// ****************************************************************************

void
avtWellLogsFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md)
{
    if (!haveReadFile)
        ReadFile();

    string meshname = "wells";
    avtMeshType mt = AVT_UNSTRUCTURED_MESH;

    int nblocks = 1; 
    int block_origin = 0;
    int spatial_dimension = 3;
    int topological_dimension = 1;
    double *extents = NULL;
    AddMeshToMetaData(md, meshname, mt, extents, nblocks, block_origin,
                      spatial_dimension, topological_dimension);

/*
    AddScalarVarToMetaData(md, "pressure", meshname, AVT_NODECENT);
    AddScalarVarToMetaData(md, "density", meshname, AVT_NODECENT);
    AddScalarVarToMetaData(md, "temperature", meshname, AVT_NODECENT);
 */

    string matname = "wellID";
    int nmats = wellNames.size();
    AddMaterialToMetaData(md, matname, meshname, nmats, wellNames);
}

// ****************************************************************************
//  Method: avtWellLogsFileFormat::ReadFile
//
//  Purpose:
//      Actually reads a CSV file and pulls out the well names and locations.
//
//  Programmer: Hank Childs and Jennifer Horsman
//  Creation:   October 19, 2010
//
// ****************************************************************************

void
avtWellLogsFileFormat::ReadFile(void)
{
    if (haveReadFile)
        return;

    std::ifstream ifile(wlFilename.c_str());
    ifile >> setprecision(9);
    if (ifile.fail())
    {
        EXCEPTION1(InvalidFilesException, wlFilename.c_str());
    }   

    std::map<int,std::string> index_map;

    char line[1024];
    ifile.getline(line, 1024);

    char *s = line;
    int idx = 0;

    do 
    {
        char *next = strstr(s, ",");
        bool atEnd = false;
        if (next == NULL || next[0] == '\0')
            atEnd = true;
        if (next != NULL)
           *(next) = '\0';
        if (!atEnd)
            next++;

        std::string key = s;

        /// create column for key
        data[key] = std::vector<std::string>();
        index_map[idx] = key;
        //std::cout << idx << " " << key << std::endl;
        s = next;
        idx++;
    } while (s != NULL && *s != '\0');

    /// read the rest of the file...
    while (!ifile.eof())
    {
        ifile.getline(line, 1024);
        int idx = 0;
        char *s = line;
        if (s[0] == '\0')
            continue;
        do
        {
            char *next = strstr(s, ",");
            bool atEnd = false;
            if (next == NULL || next[0] == '\0')
                atEnd = true;
            if (next != NULL)
               *(next) = '\0';
            if (!atEnd)
                next++;

            std::string value = s;

            /// store values...
            data[index_map[idx]].push_back(value);
            //std::cout << value << std::endl;
            s = next;
            idx++;
        } while (s != NULL && *s != '\0');
    }

    ParseFile();
}

void
avtWellLogsFileFormat::ParseFile() 
{
    std::string utm83E = "";
    std::string utm83N = "";
    std::string wellBottom = "";
    std::string groundElevation = "";
    std::string depEnv = "";

    if (data.find("UTME") != data.end())
        utm83E = "UTME";
    if (data.find("UTM83E") != data.end())
        utm83E = "UTM83E";

    if (data.find("UTM83N") != data.end())
        utm83N = "UTM83N";
    if (data.find("UTMN") != data.end()) 
        utm83N = "UTMN";

    if (data.find("WELL_BOTTOM") != data.end())
        wellBottom = "WELL_BOTTOM";
    if(data.find("interval_bottom") != data.end())
        wellBottom = "interval_bottom";
    if(data.find("BOTTOM_SCREEN_ZONE") != data.end())
        wellBottom = "BOTTOM_SCREEN_ZONE";

    if (data.find("GROUND_ELEVATION") != data.end()) {
        groundElevation = "GROUND_ELEVATION";
    }
    if (data.find("dep_env") != data.end()) {
        depEnv = "dep_env";
    }

    if (utm83E.length() == 0 || utm83N.length() == 0 || 
        wellBottom.length() == 0)
    {
        EXCEPTION1(InvalidFilesException, wlFilename.c_str())
    }

    /// checks
    std::string well = "";
    if (data.find("WELL_ID") != data.end())
    {
        well = "WELL_ID";
        if (groundElevation.length() == 0) {
            EXCEPTION1(InvalidFilesException, wlFilename.c_str())
        }
    }
    else if(data.find("site_id") != data.end()) 
    {
        well = "site_id";
        if (depEnv.length() == 0) {
            EXCEPTION1(InvalidFilesException, wlFilename.c_str())
        }
    } else if(data.find("STATION_NAME") != data.end())
    {
        well = "STATION_NAME";
        if (groundElevation.length() == 0) {
            EXCEPTION1(InvalidFilesException, wlFilename.c_str())
        }
    }else {
        EXCEPTION1(InvalidFilesException, wlFilename.c_str())
    }

    std::cerr << setprecision(9);
    std::cerr << "Ids = " << well << ", " << utm83E << ", " << utm83N << ", "
              << wellBottom << ", " << groundElevation << "," << depEnv << ","              << std::endl;

    /// VERSION 1...
    if(data.find("WELL_ID") != data.end() || 
       data.find("STATION_NAME") != data.end()) 
    {
        wellNames = data.find("WELL_ID") != data.end() ? 
                    data["WELL_ID"] : data["STATION_NAME"];

        for(size_t i = 0; i < wellNames.size(); ++i) {
            wellIds.push_back(i);
        }

        for(size_t i = 0; i < data[utm83E].size(); ++i) {
            X.push_back(atof(data[utm83E][i].c_str()));
        }

        for(size_t i = 0; i < data[utm83N].size(); ++i) {
            Y.push_back(atof(data[utm83N][i].c_str()));
        }

        for(size_t i = 0; i < data[wellBottom].size(); ++i) {
            Z1.push_back(atof(data[wellBottom][i].c_str()));
        }

        if(data.find(groundElevation) != data.end()) {
            const std::vector<std::string> &gv = data[groundElevation];
            for(size_t i = 0; i < gv.size(); ++i) {
                Z2.push_back(atof(gv[i].c_str()));
            }
        }

        if(data.find(depEnv) != data.end()) {
            const std::vector<std::string> &gv = data[depEnv];
            for(size_t i = 0; i < gv.size(); ++i) {
                Z2.push_back(atof(gv[i].c_str()));
            }
        }

        std::cout << X.size() << " " << Y.size() << " " << Z1.size() << " " << Z2.size() << std::endl;
    } else {

        /// VERSION 2
        std::map<int,int> idmap;
        const std::vector<std::string>& wellIdx = data[well];

        for(size_t i = 0; i < wellIdx.size(); ++i) {

            std::string lastWellName = "";
            float lastWellBottom = 0.0f,lasttD = 0.0f;

            std::string twellName = "";
            float tX = -1,tY = -1,tZ = -1,tD = -1;
            float prevtX = -1,prevtY = -1,prevtZ = -1,prevtD = -1;

            twellName = wellIdx[i];

            tX = atof(data[utm83E][i].c_str());
            tY = atof(data[utm83N][i].c_str());
            tZ = atof(data[wellBottom][i].c_str());
            tD = atof(data[depEnv][i].c_str());

            if(twellName != lastWellName || tD != lasttD)
            {
                if(lastWellBottom != -1 && prevtD != -1)
                {
                    int id = -1;
                    if(idmap.count(prevtD) == 0)
                    {
                        char buffer[1024];
                        sprintf(buffer,"DEP_%d",(int)prevtD);
                        wellNames.push_back(buffer);
                        id = wellNames.size() - 1;
                        idmap[prevtD] = id;
                    }
                    else
                    {
                        id = idmap[prevtD];
                    }

                    //wellNames.push_back(buffer);
                    wellIds.push_back(id); //prevtD
                    X.push_back(prevtX);
                    Y.push_back(prevtY);
                    Z1.push_back(lastWellBottom);
                    Z2.push_back(prevtZ);
                    //std::cout << prevtD << " " << prevtX << " " << prevtY << " " << lastWellBottom << " " << prevtZ << std::endl;
                }

                if(tD != lasttD && twellName == lastWellName)
                {
                    lastWellBottom = prevtZ;
                }
                else
                {
                    lastWellBottom = tZ;
                }

                //start of a new well..
                lastWellName = twellName;
                lasttD = tD;
                //std::cout << lastWellName << " " << lastWellBottom << " " << lasttD << std::endl;
            }
            else {
                prevtD = tD;
                prevtX = tX;
                prevtY = tY;
                prevtZ = tZ;
            }

            //end of file write last line out if it exists
            if(lastWellBottom != -1 && prevtD != -1)
            {
                int id = -1;
                if(idmap.count(prevtD) == 0)
                {
                    char buffer[1024];
                    sprintf(buffer,"DEP_%d",(int)prevtD);
                    wellNames.push_back(buffer);
                    id = wellNames.size() - 1;
                    idmap[prevtD] = id;
                }
                else {
                    id = idmap[prevtD];
                }

                wellIds.push_back(id);
                X.push_back(prevtX);
                Y.push_back(prevtY);
                Z1.push_back(lastWellBottom);
                Z2.push_back(prevtZ);
            }
        }
    }
    //std::cout << "Sizes " << wellIds.size() << std::endl;
    haveReadFile = true;
}

// ****************************************************************************
//  Method: avtWellLogsFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: hari -- generated by xml2avt
//  Creation:   Fri Apr 11 23:22:06 PST 2014
//
// ****************************************************************************

vtkDataSet *
avtWellLogsFileFormat::GetMesh(const char *meshname)
{
    int  i, j, k;

    // Return all well locations.
    vtkUnstructuredGrid *ugrid = vtkUnstructuredGrid::New();
    vtkPoints *pts = vtkPoints::New();
   
    int nWells = X.size();
    int pointsPerWell = 2;

    pts->SetNumberOfPoints(nWells*pointsPerWell);

    for (i = 0 ; i < nWells ; i++)
    {
        double pt[3] = { X[i], Y[i], Z1[i] };
        pts->SetPoint(2*i, pt);
        pt[2] = Z2[i];
        pts->SetPoint(2*i+1, pt);
    }
      
    ugrid->SetPoints(pts);
    pts->Delete();

    int nCellsPerWell = 1;
    int totalCells = nCellsPerWell*nWells;
    int connSizePerCell = 1+2;  // 1 to declare number of points (2)
                                // 2 for the actual points
    int connSize = connSizePerCell*totalCells;
    ugrid->Allocate(connSize);

    for (i = 0 ; i < nWells ; i++)
    {
        vtkIdType ids[2];
        ids[0] = 2*i;
        ids[1] = 2*i+1;
        ugrid->InsertNextCell(VTK_LINE, 2, ids);
    }
      
    return ugrid;
}


// ****************************************************************************
//  Method: avtWellLogsFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      varname    The name of the variable requested.
//
//  Programmer: hari -- generated by xml2avt
//  Creation:   Fri Apr 11 23:22:06 PST 2014
//
// ****************************************************************************

vtkDataArray *
avtWellLogsFileFormat::GetVar(const char *varname)
{
/*
    int ntuples = 1000; 
    vtkFloatArray *rv = vtkFloatArray::New();
    rv->SetNumberOfTuples(ntuples);
    if (strcmp(varname, "pressure") == 0)
        for (int i = 0 ; i < ntuples ; i++)
            rv->SetTuple1(i, i%10);
    if (strcmp(varname, "density") == 0)
        for (int i = 0 ; i < ntuples ; i++)
            rv->SetTuple1(i, (i/10)%10);
    if (strcmp(varname, "temperature") == 0)
        for (int i = 0 ; i < ntuples ; i++)
            rv->SetTuple1(i, i/100);
    return rv;
 */
    EXCEPTION0(ImproperUseException);
}



void *
avtWellLogsFileFormat::GetAuxiliaryData(const char *var, const char *type,
                                        void *args, DestructorFunction &df)
{
    if (strcmp(type, AUXILIARY_DATA_MATERIAL) == 0)
    {
        if (strcmp(var, "wellID") != 0)
        {
            EXCEPTION1(InvalidVariableException, var);
        }

        int nWells = wellIds.size();
        int numberOfSegments = wellIds.size(); // may be different in future
        avtMaterial *mat = new avtMaterial(nWells, wellNames, numberOfSegments,
                                           &(wellIds[0]), 0, NULL, NULL, NULL, NULL);
        df = avtMaterial::Destruct;
        return (void *) mat;
    }

    return NULL;
}


// ****************************************************************************
//  Method: avtWellLogsFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      varname    The name of the variable requested.
//
//  Programmer: hari -- generated by xml2avt
//  Creation:   Fri Apr 11 23:22:06 PST 2014
//
// ****************************************************************************

vtkDataArray *
avtWellLogsFileFormat::GetVectorVar(const char *varname)
{
    return NULL;

    //
    // If you have a file format where variables don't apply (for example a
    // strictly polygonal format like the STL (Stereo Lithography) format,
    // then uncomment the code below.
    //
    // EXCEPTION1(InvalidVariableException, varname);
    //

    //
    // If you do have a vector variable, here is some code that may be helpful.
    //
    // int ncomps = YYY;  // This is the rank of the vector - typically 2 or 3.
    // int ntuples = XXX; // this is the number of entries in the variable.
    // vtkFloatArray *rv = vtkFloatArray::New();
    // int ucomps = (ncomps == 2 ? 3 : ncomps);
    // rv->SetNumberOfComponents(ucomps);
    // rv->SetNumberOfTuples(ntuples);
    // float *one_entry = new float[ucomps];
    // for (int i = 0 ; i < ntuples ; i++)
    // {
    //      int j;
    //      for (j = 0 ; j < ncomps ; j++)
    //           one_entry[j] = ...
    //      for (j = ncomps ; j < ucomps ; j++)
    //           one_entry[j] = 0.;
    //      rv->SetTuple(i, one_entry); 
    // }
    //
    // delete [] one_entry;
    // return rv;
    //
}
