/*****************************************************************************
*
* Copyright (c) 2000 - 2012, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//  File: avtScriptFilter.C
// ************************************************************************* //

#include <avtScriptFilter.h>
#include <avtPythonFilterEnvironment.h>
#include <Python.h>
#include <vtkDataSet.h>
#include <avtRFilter.h>
#include <vector>
#include <map>
#include <ScriptOperation.h>

struct ScriptData
{
    avtRFilter* rfilter;
    std::map<std::string,ScriptOperation*> operations;
};

PyObject *
visit_functions(PyObject *self, PyObject *args);

static PyMethodDef myMethods[] =
{
    {"visit_functions",visit_functions},
    {NULL,NULL}
};

// ****************************************************************************
//  Method: avtScriptFilter constructor
//
//  Programmer: hari -- generated by xml2avt
//  Creation:   Wed Jan 16 18:16:39 PST 2013
//
// ****************************************************************************
/*
PyMethodDef conv(const char* name, PyObject* (*func)(PyObject*,PyObject*))
{
    PyMethodDef def;
    def.ml_name = name;
    def.ml_meth = func;
    def.ml_flags = 0;
    def.ml_doc = 0;
    return def;
}
*/
avtScriptFilter::avtScriptFilter()
:pyEnv(NULL)
{

    scriptData = new ScriptData();

    pyEnv = new avtPythonFilterEnvironment();

    if(!pyEnv->Initialize())
        cout << "Failed to initialize python environment.." << endl;

    PyObject* module = Py_InitModule("visit_internal_funcs",myMethods);
    PyObject* script_object = PyCObject_FromVoidPtr(this,NULL);
    PyModule_AddObject(module,"_C_API",script_object);

    std::ostringstream script;
    script  << "import sys\n"
            << "import os\n"
            << "import json\n"
            << "from flow import *\n"
            << "from flow.filters import script_pipeline\n"
            << "import visit_internal_funcs\n";

    /// register VisIt scriptable functions..
    scriptData->rfilter = dynamic_cast<avtRFilter*>(avtRFilter::Create());
    scriptData->rfilter->RegisterOperations(this);

    /// initialize environment
    if(!pyEnv->Interpreter()->RunScript(script.str()))
        cout << "Initialization Script Failed.." << endl;
}

// ****************************************************************************
//  Method: avtScriptFilter destructor
//
//  Programmer: hari -- generated by xml2avt
//  Creation:   Wed Jan 16 18:16:39 PST 2013
//
//  Modifications:
//
// ****************************************************************************

avtScriptFilter::~avtScriptFilter()
{
    if(scriptData)
    {
        delete scriptData->rfilter;
        delete scriptData;
    }
    if(pyEnv)
        delete pyEnv;
}


void
avtScriptFilter::RegisterOperation(ScriptOperation *op)
{
    ///
    std::string name;
    stringVector args;
    std::vector<ScriptOperation::ScriptVariantTypeEnum> argtypes;

    op->GetSignature(name,args,argtypes);

    /// do not register blank..
    if(name == "") return;

    scriptData->operations[name] = op;

    /// create a definition in the modules..
    std::string argstring = "";

    for(size_t i = 0; i < args.size(); ++i)
    {
        std::string arg = args[i];
        argstring += arg + (i == args.size() - 1 ? "" : ",");
    }
    std::ostringstream str;

    str << "def " << name << "( " << argstring << "):\n";

    if(argstring.size() == 0)
        str << "  return visit_internal_funcs.visit_functions('" << name << "')\n";
    else
        str << "  return visit_internal_funcs.visit_functions('" << name << "',(" << argstring << "))\n";

    str << "sys.modules['visit_internal_funcs'].__dict__['"
        << name << "'] = " << name << "\n";

    /// if R is there..
    /// register r version of same python definition..
    str << "import rpy2\n"
        << "import rpy2.robjects as robjects\n"
        << "import rpy2.robjects.numpy2ri\n"
        << "rpy2.robjects.numpy2ri.activate()\n"
        << "import rpy2.rinterface as ri\n"
        << "import visit_internal_funcs\n"

        << "def _r_" << name << "( " << argstring << "):\n";

    if(argstring.size() == 0)
        str << "  res = visit_internal_funcs.visit_functions('" << name << "')\n";
    else
        str << "  res = visit_internal_funcs.visit_functions('" << name << "',(" << argstring << "))\n";

//        << "  print res\n"
    str  << "  return rpy2.robjects.vectors.IntVector([1,2,3])\n"

         << "sys.modules['visit_internal_funcs'].__dict__['_r_"
         << name << "'] = _r_" << name << "\n"

         << "_rxp_" << name << "= ri.rternalize(visit_internal_funcs._r_" << name << ")\n"
         << "ri.globalenv['" << name << "'] = _rxp_" << name << "\n";

    //std::cout << str.str() << std::endl;

    if(!pyEnv->Interpreter()->RunScript(str.str()))
        std::cerr << "function : " << name << " registration failed" << std::endl;
}
// ****************************************************************************
//  Method:  avtScriptFilter::Create
//
//  Programmer: hari -- generated by xml2avt
//  Creation:   Wed Jan 16 18:16:39 PST 2013
//
// ****************************************************************************

avtFilter *
avtScriptFilter::Create()
{
    return new avtScriptFilter();
}


// ****************************************************************************
//  Method:      avtScriptFilter::SetAtts
//
//  Purpose:
//      Sets the state of the filter based on the attribute object.
//
//  Arguments:
//      a        The attributes to use.
//
//  Programmer: hari -- generated by xml2avt
//  Creation:   Wed Jan 16 18:16:39 PST 2013
//
// ****************************************************************************

void
avtScriptFilter::SetAtts(const AttributeGroup *a)
{
    atts = *(const ScriptAttributes*)a;
}


// ****************************************************************************
//  Method: avtScriptFilter::Equivalent
//
//  Purpose:
//      Returns true if creating a new avtScriptFilter with the given
//      parameters would result in an equivalent avtScriptFilter.
//
//  Programmer: hari -- generated by xml2avt
//  Creation:   Wed Jan 16 18:16:39 PST 2013
//
// ****************************************************************************

bool
avtScriptFilter::Equivalent(const AttributeGroup *a)
{
    return (atts == *(ScriptAttributes*)a);
}


// ****************************************************************************
//  Method: avtScriptFilter::ExecuteData
//
//  Purpose:
//      Sends the specified input and output through the Script filter.
//
//  Arguments:
//      in_ds      The input dataset.
//      <unused>   The domain number.
//      <unused>   The label.
//
//  Returns:       The output dataset.
//
//  Programmer: hari -- generated by xml2avt
//  Creation:   Wed Jan 16 18:16:39 PST 2013
//
// ****************************************************************************

#include <vtkDataArray.h>
#include <vtkPointData.h>
#include <vtkCellData.h>

vtkDataSet *
avtScriptFilter::ExecuteData(vtkDataSet *in_ds, int d, std::string s)
{
    if(!SetupFlowWorkspace())
        return in_ds;

    PyObject* py_ds_in = pyEnv->WrapVTKObject(in_ds,"vtkDataSet");
    pyEnv->Interpreter()->SetGlobalObject(py_ds_in,"ds_in");
    pyEnv->Interpreter()->SetGlobalObject(PyString_FromString(primaryVariable.c_str()),
                                          "pvar");
    std::string script = "";
    script += "ctx.init(ds_in,pvar)\n";
    script += "w.registry_add(':mesh',ds_in)\n";
    script += "w.registry_add(':pvar',pvar)\n";
    script += "res = w.execute()\n";
    if(!pyEnv->Interpreter()->RunScript(script))
    {
        cout << "Script Failed.." << endl;
        cout << pyEnv->Interpreter()->ErrorMessage() << endl;
        throw VisItException("Script failed to run properly");
    }
    // we can assume a vtkDataSet as output
    PyObject *py_res = pyEnv->Interpreter()->GetGlobalObject("res");
    if(py_ds_in == NULL)
        cout << "BAD ERROR" <<endl;
    vtkDataSet *res = (vtkDataSet*)pyEnv->UnwrapVTKObject(py_res,"vtkDataSet");
    res->Register(NULL);

    /// get data array for active variable..
    vtkDataArray* array = res->GetPointData()->GetScalars(primaryVariable.c_str());

    double range[2] = { 0, 0 };
    if(array)
    {
        array->GetRange(range);
    }
    else
    {
        array = res->GetCellData()->GetScalars(primaryVariable.c_str());
        if(array)
        {
            array->GetRange(range);
        }
    }

    avtDataAttributes &dataatts = GetOutput()->GetInfo().GetAttributes();
    avtExtents* e;

    e = dataatts.GetThisProcsOriginalDataExtents();
    e->Set(range);

    e = dataatts.GetThisProcsActualSpatialExtents();
    e->Set(range);

    e = dataatts.GetThisProcsOriginalSpatialExtents();
    e->Set(range);

    std::cout << "setting: " << range[0] << " " << range[1] << std::endl;

    return res;

}

vtkDataSet *
avtScriptFilter::ExecuteDataOld(vtkDataSet *in_ds, int, std::string)
{
    std::string script = "";
    /// Setup input dataset to python registry..
    MapNode node = atts.GetScriptMap();
    //cout << node.ToXML() << endl;
    std::string json_string = node["filter"].AsString();
    cout << json_string << endl;
    // create python string
    PyObject *py_json_str = PyString_FromString(json_string.c_str());
    pyEnv->Interpreter()->SetGlobalObject(py_json_str,"sdef_json");
    script   = "sdef = json.loads(sdef_json)\n";
    //script  += "print json.dumps(sdef,indent=2)\n";
    /// initialize environment
    if(!pyEnv->Interpreter()->RunScript(script))
    {
        cout << "Script Failed.." << endl;
        cout << pyEnv->Interpreter()->ErrorMessage() << endl;
    }
    // create a workspace
    script  = "w = Workspace()\n";
    // register the scripts
    script += "script_pipeline.register_scripts(sdef['scripts'])\n";
    script += "w.register_filters(script_pipeline)\n";
    // put the input mesh into the registry
    PyObject* py_ds_in = pyEnv->WrapVTKObject(in_ds,"vtkDataSet");
    pyEnv->Interpreter()->SetGlobalObject(py_ds_in,"ds_in");
    script += "w.registry_add(':mesh',ds_in)\n";
    // load the data flow
    script += "w.load_dict(sdef)\n";
    //script += "w.registry_add(':src_a',2)\n";
    //script += "w.registry_add(':src_b',3)\n";
    // get the visit vars
    script += "res = ds_in\n";
    script += "print w.execute()\n";
    script += "print (2+3)*(2+3) + (3-2)*(3-2)\n";    
    if(!pyEnv->Interpreter()->RunScript(script))
    {
        cout << "Script Failed.." << endl;
        cout << pyEnv->Interpreter()->ErrorMessage() << endl;
    }
    PyObject *py_res = pyEnv->Interpreter()->GetGlobalObject("res");
    if(py_ds_in == NULL)
        cout << "BAD ERROR" <<endl;
    vtkDataSet *res = (vtkDataSet*)pyEnv->UnwrapVTKObject(py_res,"vtkDataSet");

    /// get data array for active variable..
    vtkDataArray* array = res->GetPointData()->GetScalars(primaryVariable.c_str());

    double minv =0, maxv = 0;
    if(array)
    {
        minv = array->GetDataTypeMin();
        maxv = array->GetDataTypeMax();
    }
    else
    {
        array = res->GetCellData()->GetScalars(primaryVariable.c_str());
        if(array)
        {
            minv = array->GetDataTypeMin();
            maxv = array->GetDataTypeMax();
        }
    }

    avtDataAttributes &dataatts = GetOutput()->GetInfo().GetAttributes();
    avtExtents* e = dataatts.GetThisProcsActualDataExtents();

    double range[2];
    range[0] = minv;
    range[1] = maxv;
    e->Set(range);
    std::cout << "setting: " << minv << " " << maxv << std::endl;

    res->Register(NULL);
    return res;

}


bool avtScriptFilter::SetupFlowWorkspace()
{
    std::string script = "";
    MapNode node = atts.GetScriptMap();

    if(!node.HasEntry("filter")) return false;

    std::string json_string = node["filter"].AsString();

    // create python string
    PyObject *py_json_str = PyString_FromString(json_string.c_str());
    pyEnv->Interpreter()->SetGlobalObject(py_json_str,"sdef_json");
    script  = "sdef = json.loads(sdef_json)\n";
    //script += "print json.dumps(sdef,indent=2)\n";
    // create a workspace
    script += "w = Workspace()\n";
    // register the scripts
    script += "script_pipeline.register_scripts(sdef['scripts'])\n";
    script += "w.register_filters(script_pipeline)\n";
    script += "ctx = w.add_context('script_pipeline','<default_context>')\n";
    // put the input mesh into the registry
    // load the data flow
    script += "w.load_dict(sdef)\n";
    if(!pyEnv->Interpreter()->RunScript(script))
    {
        cout << "Script Failed.." << endl;
        cout << pyEnv->Interpreter()->ErrorMessage() << endl;
        throw VisItException("Workspace setup has failed");
    }
    return true;
}


// ****************************************************************************
//  Method:  avtScriptFilter::ModifyContract
//
//  Purpose:
//    Adds secondary variable request.
//
//  Arguments:
//    spec       the pipeline specification
//
//  Programmer:  Cyrus Harrison
//  Creation:    Mon Feb  4 15:26:10 PST 2013
//
//  Modifications:
//
// ****************************************************************************
avtContract_p
avtScriptFilter::ModifyContract(avtContract_p spec)
{
    //
    // Get the old specification.
    //
    avtDataRequest_p ds = spec->GetDataRequest();
    
    // set this so we can use the name in exec data
    primaryVariable = std::string(ds->GetVariable());
    cout <<"primaryVariable = " << primaryVariable <<endl;
    //
    // Make a new one
    //
    avtDataRequest_p nds = new avtDataRequest(ds);

    /// if setup has failed then return immediately...
    if(!SetupFlowWorkspace()) return new avtContract(spec, nds);

    // we need to find out what visit vars we need to request
    std::string script = "";
    script += "__vars = w.filter_names()\n";
    script += "__vars = [ var[1:] for var in __vars if var[0] == ':' and var != ':mesh' and var != ':pvar']";
    if(!pyEnv->Interpreter()->RunScript(script))
    {
        cout << "Script Failed.." << endl;
        cout << pyEnv->Interpreter()->ErrorMessage() << endl;
        throw VisItException("Contract extraction failed..");
    }
    
    PyObject *py_vars   = pyEnv->Interpreter()->GetGlobalObject("__vars");
    PyObject *py_r_vars = PySequence_Fast(py_vars,"Expected Sequence");

    int n_vars          = PySequence_Size(py_r_vars);    
    // process all vars
    for(int i = 0; i < n_vars ; i++)
    {
        PyObject *py_var_str = PySequence_Fast_GET_ITEM(py_r_vars,i);  // borrowed
        std::string var_str = std::string(PyString_AsString(py_var_str));
        if (primaryVariable != var_str && var_str != std::string("default"))
        {
            cout << "Adding \"" << var_str << "\" as secondary var" <<endl;
            nds->AddSecondaryVariable(var_str.c_str());
        }
    }
    
    //
    // Create the new pipeline spec from the data spec, and return
    //
    avtContract_p rv = new avtContract(spec, nds);

    return rv;
}


/// Python script filter functions..
PyObject *
visit_foreach_file(PyObject *self, PyObject *args)
{
    Py_INCREF(Py_None);
    return Py_None;
}

PyObject *
visit_foreach_location(PyObject *self, PyObject *args)
{
    Py_INCREF(Py_None);
    return Py_None;
}


bool convert(ScriptOperation::ScriptVariantTypeEnum& type, PyObject* obj, Variant& result)
{
    bool success = true;
    switch(type)
    {
        case ScriptOperation::BOOL_TYPE:
        {
        std::cout << "meow?" << PyBool_Check(obj) << std::endl;
            PyBool_Check(obj) ? result = (obj == Py_False ? false: true ) : success = false;
            break;
        }
        case ScriptOperation::CHAR_TYPE:
        {
            PyString_Check(obj) ? result = PyString_AsString(obj) : success = false;
            break;
        }
        case ScriptOperation::UNSIGNED_CHAR_TYPE:
        {
            PyString_Check(obj) ? result = PyString_AsString(obj) : success = false;
            break;
        }
        case ScriptOperation::INT_TYPE:
    {
        PyInt_Check(obj) ? result = (int)PyInt_AsLong(obj) : success = false;
        break;
    }

        case ScriptOperation::LONG_TYPE:
    {
        PyLong_Check(obj) ? result = (long)PyLong_AsLong(obj) : success = false;
        break;
    }
        case ScriptOperation::FLOAT_TYPE:
    {
        PyFloat_Check(obj) ? result = (float)PyFloat_AsDouble(obj) : success = false;
        break;
    }
        case ScriptOperation::DOUBLE_TYPE:
    {
        PyFloat_Check(obj) ? result = (double)PyFloat_AsDouble(obj) : success = false;
        break;
    }
        case ScriptOperation::STRING_TYPE:
    {
        PyString_Check(obj) ? result = (const char*)PyString_AsString(obj) : success = false;
        break;
    }
        case ScriptOperation::BOOL_VECTOR_TYPE:
        case ScriptOperation::CHAR_VECTOR_TYPE:
        case ScriptOperation::UNSIGNED_CHAR_VECTOR_TYPE:
        case ScriptOperation::INT_VECTOR_TYPE:
        case ScriptOperation::LONG_VECTOR_TYPE:
        case ScriptOperation::FLOAT_VECTOR_TYPE:
        case ScriptOperation::DOUBLE_VECTOR_TYPE:
        case ScriptOperation::STRING_VECTOR_TYPE:
    {
        if(PyTuple_Check(obj)  == 0 || PyList_Check(obj) == 0)
        {
            success = false;
            break;
        }
        /*
        switch(type)
        {
            case BOOL_VECTOR_TYPE: { subtype = BOOL_TYPE; result = boolVector(); break; }
            case CHAR_VECTOR_TYPE: { result = charsVector(); break; }
            case UNSIGNED_CHAR_VECTOR_TYPE: { result = unsignedCharVector(); break; }
            case INT_VECTOR_TYPE: { result = intVector(); break; }
            case LONG_VECTOR_TYPE: { result = longVector(); break; }
            case FLOAT_VECTOR_TYPE: { result = floatVector(); break; }
            case DOUBLE_VECTOR_TYPE:{ result = doubleVector(); break; }
            case STRING_VECTOR_TYPE:{ result = stringVector(); break; }
        };

        if(PyTuple_Check(obj))
        {
            // Extract arguments from the tuple.

            for(int i = 0; i < PyTuple_Size(obj); ++i)
            {
                PyObject *item = PyTuple_GET_ITEM(obj, i);
                Variant v;
                convert(subtype)
            }
        }
        else
        {
            // Extract arguments from the list.
            for(int i = 0; i < PyList_Size(obj); ++i)
            {
                PyObject *item = PyList_GET_ITEM(obj, i);
            }
        }
        */
        break;
    }
    case ScriptOperation::VTK_DATA_ARRAY_TYPE:
    case ScriptOperation::VTK_DATASET_ARRAY_TYPE:
    default: break;
    };
    return success;
}
PyObject *
visit_functions(PyObject *self, PyObject *args)
{
    char* name = 0;
    PyObject* scriptArgs = NULL;

    std::cout << " called: " << self << " " << args << std::endl;

    ///if args is just the function call..
    if(PyString_Check(args))
    {
        std::cout << "NAME!" << std::endl;
        name = PyString_AsString(args);
    }
    else
    {
        PyArg_ParseTuple(args,"sO",&name,&scriptArgs);
        std::cout << "NAME: " << name << std::endl;
    }

    if(!name) return NULL;

    /// Get reference to module..
    PyObject *m = PyImport_ImportModule("visit_internal_funcs");

    /// TODO: return error..
    if (!m) { Py_INCREF(Py_None); return NULL; }

    PyObject *c_api_object = PyObject_GetAttrString(m, "_C_API");

    /// TODO: return error..
    if (!c_api_object) { Py_INCREF(Py_None); Py_DECREF(m); return NULL; }

    avtScriptFilter *scriptFilter = (avtScriptFilter *)PyCObject_AsVoidPtr(c_api_object);

    /// Parse arguments..

    std::cout << "running: " << scriptFilter << std::endl;

    ScriptData* sd = scriptFilter->GetScriptData();

    if(sd->operations.count(name) == 0) return NULL;

    ScriptOperation* op = sd->operations[name];

    std::string op_name;
    stringVector op_argnames;
    std::vector<ScriptOperation::ScriptVariantTypeEnum> op_argtypes;

    ScriptOperation::ScriptOperationResponse op_resp = op->GetSignature(op_name,op_argnames,op_argtypes);

    std::vector<Variant> variantArgs;

    // Extract arguments from the tuple.
    if(PyTuple_Size(scriptArgs) != op_argtypes.size())
    {
        std::cerr << "sizes do not match!" << std::endl;
        return NULL;
    }
    for(int i = 0; i < PyTuple_Size(scriptArgs); ++i)
    {
        Variant v;
        PyObject *item = PyTuple_GET_ITEM(scriptArgs, i);
        std::cout << op_argnames[i] << " " << op_argtypes[i] << " " << convert(op_argtypes[i],item,v) << std::endl;

        variantArgs.push_back(v);
    }

    for(int i = 0; i < variantArgs.size(); ++i)
    {
        Variant v = variantArgs[i];
        std::cout << v.ToJSON() << std::endl;
    }


//    avtDataset_p result;

//    if(!op->func(scriptFilter->GetInput(),
//             scriptFilter->GetGeneralContract(),
//             variantArgs, result))

//    {
//        std::cerr << "operation failed!" << std::endl;
//        Py_DECREF(c_api_object);
//        Py_DECREF(m);
//        return NULL;
//    }

//    avtDataTree_p tree = scriptFilter->GetDataTree(result);

//    int leaves = 0;
//    vtkDataSet** datasets = tree->GetAllLeaves(leaves);

//    //std::cout << leaves << std::endl;
//    if(leaves != -1)
//    {
//        PyObject* out = scriptFilter->GetPythonEnvironment()->WrapVTKObject(datasets[0],"vtkDataSet");
//        //std::cout << out << std::endl;

//        Py_DECREF(c_api_object);
//        Py_DECREF(m);

//        return out;
//    }

    Py_INCREF(scriptArgs);
    //Py_DECREF(c_api_object);
    Py_DECREF(m);

    Py_INCREF(Py_None);
    return Py_None;
}
