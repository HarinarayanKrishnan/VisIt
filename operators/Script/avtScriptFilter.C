/*****************************************************************************
*
* Copyright (c) 2000 - 2012, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//  File: avtScriptFilter.C
// ************************************************************************* //

#include <avtScriptFilter.h>
#include <avtPythonFilterEnvironment.h>
#include <Python.h>
#include <vtkDataSet.h>
#include <avtRFilter.h>
#include <vector>
#include <map>
#include <ScriptOperation.h>
#include <avtOriginatingSource.h>
#include <avtScriptOperation.h>

struct ScriptData
{
    avtRFilter* rfilter;
    avtScriptOperation* sfilter;
    std::map<std::string,ScriptOperation*> operations;
};

PyObject *
visit_functions(PyObject *self, PyObject *args);

static PyMethodDef myMethods[] =
{
    {"visit_functions",visit_functions},
    {NULL,NULL}
};

// ****************************************************************************
//  Method: avtScriptFilter constructor
//
//  Programmer: hari -- generated by xml2avt
//  Creation:   Wed Jan 16 18:16:39 PST 2013
//
// ****************************************************************************
/*
PyMethodDef conv(const char* name, PyObject* (*func)(PyObject*,PyObject*))
{
    PyMethodDef def;
    def.ml_name = name;
    def.ml_meth = func;
    def.ml_flags = 0;
    def.ml_doc = 0;
    return def;
}
*/
avtScriptFilter::avtScriptFilter()
:pyEnv(NULL)
{

    scriptData = new ScriptData();

    pyEnv = new avtPythonFilterEnvironment();

    if(!pyEnv->Initialize())
        cout << "Failed to initialize python environment.." << endl;

    PyObject* module = Py_InitModule("visit_internal_funcs",myMethods);
    PyObject* script_object = PyCObject_FromVoidPtr(this,NULL);
    PyModule_AddObject(module,"_C_API",script_object);

    std::ostringstream script;
    script  << "import sys\n"
            << "import os\n"
            << "import json\n"
            << "from flow import *\n"
            << "from flow.filters import script_pipeline\n"
            << "import visit_internal_funcs\n";

    /// initialize environment
    if(!pyEnv->Interpreter()->RunScript(script.str()))
        cout << "Initialization Script Failed.." << endl;

    /// register VisIt scriptable functions..
    scriptData->rfilter = dynamic_cast<avtRFilter*>(avtRFilter::Create());
    scriptData->rfilter->RegisterOperations(this);

    scriptData->sfilter = new avtScriptOperation();
    scriptData->sfilter->RegisterOperations(this);
}

// ****************************************************************************
//  Method: avtScriptFilter destructor
//
//  Programmer: hari -- generated by xml2avt
//  Creation:   Wed Jan 16 18:16:39 PST 2013
//
//  Modifications:
//
// ****************************************************************************

avtScriptFilter::~avtScriptFilter()
{
    if(scriptData)
    {
        delete scriptData->rfilter;
        delete scriptData->sfilter;
        delete scriptData;
    }
    if(pyEnv)
        delete pyEnv;
}


void
avtScriptFilter::RegisterOperation(ScriptOperation *op)
{
    ///
    std::string name;
    stringVector args;
    std::vector<ScriptOperation::ScriptVariantTypeEnum> argtypes;

    op->GetSignature(name,args,argtypes);

    /// do not register blank..
    if(name == "") return;

    scriptData->operations[name] = op;

    /// create a definition in the modules..
    std::ostringstream cast_to_numpy;
    std::string argstring = "";

    for(size_t i = 0; i < args.size(); ++i)
    {
        std::string arg = args[i];
        argstring += arg + (i == args.size() - 1 ? "" : ",");

        /// convert numpy to vtk...
        if(argtypes[i] == ScriptOperation::VTK_DATA_ARRAY_TYPE)
        {
            cast_to_numpy << "    if not isinstance(" << args[i] << ", vtk.vtkDataArray):\n";
            cast_to_numpy << "        " << args[i] << " = vtk.util.numpy_support.numpy_to_vtk(" << args[i] << ")\n";
        }
    }
    std::ostringstream str;

    str << "def " << name << "(" << argstring << "):\n";
    str << "    import vtk,vtk.util.numpy_support\n";
    if(cast_to_numpy.str().size() > 0)
        str << cast_to_numpy.str();

    if(argstring.size() == 0)
        str << "    res = visit_internal_funcs.visit_functions('" << name << "')\n";
    else
        str << "    res = visit_internal_funcs.visit_functions('" << name << "',(" << argstring << "))\n";
    str << "    return res\n";

    /// convert from vtk to numpy if needed..

    str << "sys.modules['visit_internal_funcs'].__dict__['"
        << name << "'] = " << name << "\n";

    /// if R is there..
    /// register r version of same python definition..
    str << "import rpy2\n"
        << "import rpy2.robjects as robjects\n"
        << "import rpy2.robjects.numpy2ri\n"
        << "rpy2.robjects.numpy2ri.activate()\n"
        << "import rpy2.rinterface as ri\n"
        << "import visit_internal_funcs\n"

        << "def _r_" << name << "(" << argstring << "):\n";

    if(argstring.size() == 0)
        str << "  res = visit_internal_funcs.visit_functions('" << name << "')\n";
    else
        str << "  res = visit_internal_funcs.visit_functions('" << name << "',(" << argstring << "))\n";

//        << "  print res\n"
    str  << "  return rpy2.robjects.default_py2ri(res)\n"

         << "sys.modules['visit_internal_funcs'].__dict__['_r_"
         << name << "'] = _r_" << name << "\n"

         << "_rxp_" << name << "= ri.rternalize(visit_internal_funcs._r_" << name << ")\n"
         << "ri.globalenv['" << name << "'] = _rxp_" << name << "\n";

    //std::cout << str.str() << std::endl;
    //std::cout << "--------------------------------" << std::endl;

    if(!pyEnv->Interpreter()->RunScript(str.str()))
        std::cerr << "function : " << name << " registration failed" << std::endl;
}
// ****************************************************************************
//  Method:  avtScriptFilter::Create
//
//  Programmer: hari -- generated by xml2avt
//  Creation:   Wed Jan 16 18:16:39 PST 2013
//
// ****************************************************************************

avtFilter *
avtScriptFilter::Create()
{
    return new avtScriptFilter();
}


// ****************************************************************************
//  Method:      avtScriptFilter::SetAtts
//
//  Purpose:
//      Sets the state of the filter based on the attribute object.
//
//  Arguments:
//      a        The attributes to use.
//
//  Programmer: hari -- generated by xml2avt
//  Creation:   Wed Jan 16 18:16:39 PST 2013
//
// ****************************************************************************

void
avtScriptFilter::SetAtts(const AttributeGroup *a)
{
    atts = *(const ScriptAttributes*)a;
}


// ****************************************************************************
//  Method: avtScriptFilter::Equivalent
//
//  Purpose:
//      Returns true if creating a new avtScriptFilter with the given
//      parameters would result in an equivalent avtScriptFilter.
//
//  Programmer: hari -- generated by xml2avt
//  Creation:   Wed Jan 16 18:16:39 PST 2013
//
// ****************************************************************************

bool
avtScriptFilter::Equivalent(const AttributeGroup *a)
{
    return (atts == *(ScriptAttributes*)a);
}


// ****************************************************************************
//  Method: avtScriptFilter::ExecuteData
//
//  Purpose:
//      Sends the specified input and output through the Script filter.
//
//  Arguments:
//      in_ds      The input dataset.
//      <unused>   The domain number.
//      <unused>   The label.
//
//  Returns:       The output dataset.
//
//  Programmer: hari -- generated by xml2avt
//  Creation:   Wed Jan 16 18:16:39 PST 2013
//
// ****************************************************************************

#include <vtkDataArray.h>
#include <vtkPointData.h>
#include <vtkCellData.h>

vtkDataSet *
avtScriptFilter::ExecuteData(vtkDataSet *in_ds, int d, std::string s)
{
    if(!SetupFlowWorkspace())
        return in_ds;

    PyObject* py_ds_in = pyEnv->WrapVTKObject(in_ds,"vtkDataSet");
    pyEnv->Interpreter()->SetGlobalObject(py_ds_in,"ds_in");
    pyEnv->Interpreter()->SetGlobalObject(PyString_FromString(primaryVariable.c_str()),
                                          "pvar");
    std::string script = "";
    script += "ctx.init(ds_in,pvar)\n";
    script += "w.registry_add(':mesh',ds_in)\n";
    script += "w.registry_add(':pvar',pvar)\n";
    script += "res = w.execute()\n";
    if(!pyEnv->Interpreter()->RunScript(script))
    {
        cout << "Script Failed.." << endl;
        cout << pyEnv->Interpreter()->ErrorMessage() << endl;
        throw VisItException("Script failed to run properly");
    }
    // we can assume a vtkDataSet as output
    PyObject *py_res = pyEnv->Interpreter()->GetGlobalObject("res");
    if(py_ds_in == NULL)
        cout << "BAD ERROR" <<endl;
    vtkDataSet *res = (vtkDataSet*)pyEnv->UnwrapVTKObject(py_res,"vtkDataSet");
    res->Register(NULL);

    /// get data array for active variable..
    vtkDataArray* array = res->GetPointData()->GetScalars(primaryVariable.c_str());

    double range[2] = { 0, 0 };
    if(array)
    {
        array->GetRange(range);
    }
    else
    {
        array = res->GetCellData()->GetScalars(primaryVariable.c_str());
        if(array)
        {
            array->GetRange(range);
        }
    }

    avtDataAttributes &dataatts = GetOutput()->GetInfo().GetAttributes();
    avtExtents* e;

    e = dataatts.GetThisProcsOriginalDataExtents();
    e->Set(range);

    e = dataatts.GetThisProcsActualSpatialExtents();
    e->Set(range);

    e = dataatts.GetThisProcsOriginalSpatialExtents();
    e->Set(range);

    std::cout << "setting: " << range[0] << " " << range[1] << std::endl;

    return res;

}

vtkDataSet *
avtScriptFilter::ExecuteDataOld(vtkDataSet *in_ds, int, std::string)
{
    std::string script = "";
    /// Setup input dataset to python registry..
    MapNode node = atts.GetScriptMap();
    //cout << node.ToXML() << endl;
    std::string json_string = node["filter"].AsString();
    cout << json_string << endl;
    // create python string
    PyObject *py_json_str = PyString_FromString(json_string.c_str());
    pyEnv->Interpreter()->SetGlobalObject(py_json_str,"sdef_json");
    script   = "sdef = json.loads(sdef_json)\n";
    //script  += "print json.dumps(sdef,indent=2)\n";
    /// initialize environment
    if(!pyEnv->Interpreter()->RunScript(script))
    {
        cout << "Script Failed.." << endl;
        cout << pyEnv->Interpreter()->ErrorMessage() << endl;
    }
    // create a workspace
    script  = "w = Workspace()\n";
    // register the scripts
    script += "script_pipeline.register_scripts(sdef['scripts'])\n";
    script += "w.register_filters(script_pipeline)\n";
    // put the input mesh into the registry
    PyObject* py_ds_in = pyEnv->WrapVTKObject(in_ds,"vtkDataSet");
    pyEnv->Interpreter()->SetGlobalObject(py_ds_in,"ds_in");
    script += "w.registry_add(':mesh',ds_in)\n";
    // load the data flow
    script += "w.load_dict(sdef)\n";
    //script += "w.registry_add(':src_a',2)\n";
    //script += "w.registry_add(':src_b',3)\n";
    // get the visit vars
    script += "res = ds_in\n";
    script += "print w.execute()\n";
    script += "print (2+3)*(2+3) + (3-2)*(3-2)\n";    
    if(!pyEnv->Interpreter()->RunScript(script))
    {
        cout << "Script Failed.." << endl;
        cout << pyEnv->Interpreter()->ErrorMessage() << endl;
    }
    PyObject *py_res = pyEnv->Interpreter()->GetGlobalObject("res");
    if(py_ds_in == NULL)
        cout << "BAD ERROR" <<endl;
    vtkDataSet *res = (vtkDataSet*)pyEnv->UnwrapVTKObject(py_res,"vtkDataSet");

    /// get data array for active variable..
    vtkDataArray* array = res->GetPointData()->GetScalars(primaryVariable.c_str());

    double minv =0, maxv = 0;
    if(array)
    {
        minv = array->GetDataTypeMin();
        maxv = array->GetDataTypeMax();
    }
    else
    {
        array = res->GetCellData()->GetScalars(primaryVariable.c_str());
        if(array)
        {
            minv = array->GetDataTypeMin();
            maxv = array->GetDataTypeMax();
        }
    }

    avtDataAttributes &dataatts = GetOutput()->GetInfo().GetAttributes();
    avtExtents* e = dataatts.GetThisProcsActualDataExtents();

    double range[2];
    range[0] = minv;
    range[1] = maxv;
    e->Set(range);
    std::cout << "setting: " << minv << " " << maxv << std::endl;

    res->Register(NULL);
    return res;

}


bool avtScriptFilter::SetupFlowWorkspace()
{
    std::string script = "";
    MapNode node = atts.GetScriptMap();

    if(!node.HasEntry("filter")) return false;

    std::string json_string = node["filter"].AsString();

    // create python string
    PyObject *py_json_str = PyString_FromString(json_string.c_str());
    pyEnv->Interpreter()->SetGlobalObject(py_json_str,"sdef_json");
    script  = "sdef = json.loads(sdef_json)\n";
    //script += "print json.dumps(sdef,indent=2)\n";
    // create a workspace
    script += "w = Workspace()\n";
    // register the scripts
    script += "script_pipeline.register_scripts(sdef['scripts'])\n";
    script += "w.register_filters(script_pipeline)\n";
    script += "ctx = w.add_context('script_pipeline','<default_context>')\n";
    // put the input mesh into the registry
    // load the data flow
    script += "w.load_dict(sdef)\n";
    if(!pyEnv->Interpreter()->RunScript(script))
    {
        cout << "Script Failed.." << endl;
        cout << pyEnv->Interpreter()->ErrorMessage() << endl;
        throw VisItException("Workspace setup has failed");
    }
    return true;
}


// ****************************************************************************
//  Method:  avtScriptFilter::ModifyContract
//
//  Purpose:
//    Adds secondary variable request.
//
//  Arguments:
//    spec       the pipeline specification
//
//  Programmer:  Cyrus Harrison
//  Creation:    Mon Feb  4 15:26:10 PST 2013
//
//  Modifications:
//
// ****************************************************************************
avtContract_p
avtScriptFilter::ModifyContract(avtContract_p spec)
{
    //
    // Get the old specification.
    //
    avtDataRequest_p ds = spec->GetDataRequest();
    
    // set this so we can use the name in exec data
    primaryVariable = std::string(ds->GetVariable());
    cout <<"primaryVariable = " << primaryVariable <<endl;
    //
    // Make a new one
    //
    avtDataRequest_p nds = new avtDataRequest(ds);

    /// if setup has failed then return immediately...
    if(!SetupFlowWorkspace()) return new avtContract(spec, nds);

    // we need to find out what visit vars we need to request
    std::string script = "";
    script += "__vars = w.filter_names()\n";
    script += "__vars = [ var[1:] for var in __vars if var[0] == ':' and var != ':mesh' and var != ':pvar']";
    if(!pyEnv->Interpreter()->RunScript(script))
    {
        cout << "Script Failed.." << endl;
        cout << pyEnv->Interpreter()->ErrorMessage() << endl;
        throw VisItException("Contract extraction failed..");
    }
    
    PyObject *py_vars   = pyEnv->Interpreter()->GetGlobalObject("__vars");
    PyObject *py_r_vars = PySequence_Fast(py_vars,"Expected Sequence");

    int n_vars          = PySequence_Size(py_r_vars);    
    // process all vars
    for(int i = 0; i < n_vars ; i++)
    {
        PyObject *py_var_str = PySequence_Fast_GET_ITEM(py_r_vars,i);  // borrowed
        std::string var_str = std::string(PyString_AsString(py_var_str));
        if (primaryVariable != var_str && var_str != std::string("default"))
        {
            cout << "Adding \"" << var_str << "\" as secondary var" <<endl;
            nds->AddSecondaryVariable(var_str.c_str());
        }
    }
    
    //
    // Create the new pipeline spec from the data spec, and return
    //
    avtContract_p rv = new avtContract(spec, nds);

    return rv;
}


/// Python script filter functions..

void addToVariant(ScriptOperation::ScriptVariantTypeEnum& subtype, Variant& result, Variant& v)
{
    if(subtype == ScriptOperation::BOOL_TYPE)
        result.AsBoolVector().push_back(v.AsBool());
    else if(subtype == ScriptOperation::CHAR_TYPE)
        result.AsCharVector().push_back(v.AsChar());
    else if(subtype == ScriptOperation::UNSIGNED_CHAR_TYPE)
        result.AsUnsignedCharVector().push_back(v.AsUnsignedChar());
    else if(subtype == ScriptOperation::INT_TYPE)
        result.AsIntVector().push_back(v.AsInt());
    else if(subtype == ScriptOperation::LONG_TYPE)
        result.AsLongVector().push_back(v.AsLong());
    else if(subtype == ScriptOperation::FLOAT_TYPE)
        result.AsFloatVector().push_back(v.AsFloat());
    else if(subtype == ScriptOperation::DOUBLE_TYPE)
        result.AsDoubleVector().push_back(v.AsDouble());
    else if(subtype == ScriptOperation::STRING_TYPE)
        result.AsStringVector().push_back(v.AsString());
}

bool convert(const ScriptOperation::ScriptVariantTypeEnum& type, PyObject* obj, Variant& result)
{
    bool success = true;
    switch(type)
    {
        case ScriptOperation::BOOL_TYPE:
        {
            PyBool_Check(obj) ? result = (obj == Py_False ? false: true ) : success = false;
            break;
        }
        case ScriptOperation::CHAR_TYPE:
        {
            PyString_Check(obj) && PyString_Size(obj) > 0 ? result = PyString_AsString(obj)[0] : success = false;
            break;
        }
        case ScriptOperation::UNSIGNED_CHAR_TYPE:
        {
            PyString_Check(obj)  && PyString_Size(obj) > 0 ? result = (unsigned char) PyString_AsString(obj)[0] : success = false;
            break;
        }
        case ScriptOperation::INT_TYPE:
        {
            PyInt_Check(obj) ? result = (int)PyInt_AsLong(obj) : success = false;
            break;
        }
        case ScriptOperation::LONG_TYPE:
        {
            PyLong_Check(obj) ? result = (long)PyLong_AsLong(obj) : success = false;
            break;
        }
        case ScriptOperation::FLOAT_TYPE:
        {
            PyFloat_Check(obj) ? result = (float)PyFloat_AsDouble(obj) : success = false;
            break;
        }
        case ScriptOperation::DOUBLE_TYPE:
        {
            PyFloat_Check(obj) ? result = (double)PyFloat_AsDouble(obj) : success = false;
            break;
        }
        case ScriptOperation::STRING_TYPE:
        {
            PyString_Check(obj) ? result = (const char*)PyString_AsString(obj) : success = false;
            break;
        }
        case ScriptOperation::VARIANT_TYPE:
        {
            if (PyBool_Check(obj)) result = (obj == Py_False ? false: true );
            else if(PyInt_Check(obj)) result = (int)PyInt_AsLong(obj);
            else if(PyLong_Check(obj)) result = (long)PyLong_AsLong(obj);
            else if(PyFloat_Check(obj)) result = (double)PyFloat_AsDouble(obj);
            else if(PyString_Check(obj)) result = (const char*)PyString_AsString(obj);
            else
            {
                success = false;
            }
            break;
        }
        case ScriptOperation::BOOL_VECTOR_TYPE:
        case ScriptOperation::CHAR_VECTOR_TYPE:
        case ScriptOperation::UNSIGNED_CHAR_VECTOR_TYPE:
        case ScriptOperation::INT_VECTOR_TYPE:
        case ScriptOperation::LONG_VECTOR_TYPE:
        case ScriptOperation::FLOAT_VECTOR_TYPE:
        case ScriptOperation::DOUBLE_VECTOR_TYPE:
        case ScriptOperation::STRING_VECTOR_TYPE:
    {
        if(!PyTuple_Check(obj) && !PyList_Check(obj))
        {
            success = false;
            break;
        }

        ScriptOperation::ScriptVariantTypeEnum subtype;
        switch(type)
        {
            case ScriptOperation::BOOL_VECTOR_TYPE: { subtype = ScriptOperation::BOOL_TYPE; result = boolVector(); break; }
            case ScriptOperation::CHAR_VECTOR_TYPE: { subtype = ScriptOperation::CHAR_TYPE; result = charVector(); break; }
            case ScriptOperation::UNSIGNED_CHAR_VECTOR_TYPE: { subtype = ScriptOperation::UNSIGNED_CHAR_TYPE; result = unsignedCharVector(); break; }
            case ScriptOperation::INT_VECTOR_TYPE: { subtype = ScriptOperation::INT_TYPE; result = intVector(); break; }
            case ScriptOperation::LONG_VECTOR_TYPE: { subtype = ScriptOperation::LONG_TYPE; result = longVector(); break; }
            case ScriptOperation::FLOAT_VECTOR_TYPE: { subtype = ScriptOperation::FLOAT_TYPE; result = floatVector(); break; }
            case ScriptOperation::DOUBLE_VECTOR_TYPE:{ subtype = ScriptOperation::DOUBLE_TYPE; result = doubleVector(); break; }
            case ScriptOperation::STRING_VECTOR_TYPE:{ subtype = ScriptOperation::STRING_TYPE; result = stringVector(); break; }
        };

        if(PyTuple_Check(obj))
        {
            // Extract arguments from the tuple.
            for(int i = 0; i < PyTuple_Size(obj); ++i)
            {
                PyObject *item = PyTuple_GET_ITEM(obj, i);
                Variant v;
                if(!convert(subtype,item,v))
                    success = false;
                addToVariant(subtype,result,v);
            }
        }
        else if(PyList_Check(obj))
        {
            // Extract arguments from the list.
            for(int i = 0; i < PyList_Size(obj); ++i)
            {
                PyObject *item = PyList_GET_ITEM(obj, i);
                Variant v;
                if(!convert(subtype,item,v))
                    success = false;
                addToVariant(subtype,result,v);
            }
        }
        else
        {
            std::cerr << "avtScriptFilter::convert error should not be here.." << std::endl;
            success = false;
        }
        break;
    }
    case ScriptOperation::VTK_DATA_ARRAY_TYPE:
    case ScriptOperation::VTK_DATASET_TYPE:
    case ScriptOperation::VTK_AVTDATASET_TYPE:
    default: break;
    };
    return success;
}

PyObject *
visit_functions(PyObject *self, PyObject *args)
{
    char* name = 0;
    PyObject* scriptArgs = NULL;

    ///if args is just the function call..
    if(PyString_Check(args))
        name = PyString_AsString(args);
    else
        PyArg_ParseTuple(args,"sO",&name,&scriptArgs);

    if(!name) return NULL;

    /// Get reference to module..
    PyObject *m = PyImport_ImportModule("visit_internal_funcs");

    /// TODO: return error..
    if (!m) { Py_INCREF(Py_None); return NULL; }

    PyObject *c_api_object = PyObject_GetAttrString(m, "_C_API");

    /// TODO: return error..
    if (!c_api_object) { Py_INCREF(Py_None); Py_DECREF(m); return NULL; }

    avtScriptFilter *scriptFilter = (avtScriptFilter *)PyCObject_AsVoidPtr(c_api_object);

    /// Parse arguments..

    std::cout << "running: " << scriptFilter << std::endl;

    ScriptData* sd = scriptFilter->GetScriptData();

    if(sd->operations.count(name) == 0) return NULL;

    ScriptOperation* op = sd->operations[name];

    std::string op_name;
    stringVector op_argnames;
    std::vector<ScriptOperation::ScriptVariantTypeEnum> op_argtypes;

    ScriptOperation::ScriptOperationResponse op_resp = op->GetSignature(op_name,op_argnames,op_argtypes);

    std::vector<Variant> variantArgs;
    std::map<int,void*> datamap;
    std::map<int, std::vector<Variant> > variantVecMap;

    // Extract arguments from the tuple.
    if(scriptArgs)
    {
        if(PyTuple_Size(scriptArgs) != op_argtypes.size())
        {
            std::cerr << "sizes do not match!" << std::endl;
            return NULL;
        }
        for(int i = 0; i < PyTuple_Size(scriptArgs); ++i)
        {
            Variant v;
            PyObject *item = PyTuple_GET_ITEM(scriptArgs, i);

            if(op_argtypes[i] == ScriptOperation::VTK_DATA_ARRAY_TYPE)
            {
                void* vobj = scriptFilter->GetPythonEnvironment()->UnwrapVTKObject(item, "vtkDataArray");
                datamap[i] = vobj;
            }
            else if(op_argtypes[i] == ScriptOperation::VARIANT_VECTOR_TYPE)
            {
                std::vector<Variant> variantVec;

                if(!PyTuple_Check(item) && !PyList_Check(item))
                {
                    variantArgs.push_back(v); ///null..
                    variantVecMap[i] = variantVec;
                    continue;
                }

                if(PyTuple_Check(item))
                {
                    // Extract arguments from the tuple.
                    for(int j = 0; j < PyTuple_Size(item); ++j)
                    {
                        PyObject *itemx = PyTuple_GET_ITEM(item, j);
                        Variant v;
                        convert(ScriptOperation::VARIANT_TYPE,itemx,v);
                        variantVec.push_back(v);
                    }
                }
                else
                {
                    // Extract arguments from the list.
                    for(int j = 0; j < PyList_Size(item); ++j)
                    {
                        PyObject *itemx = PyList_GET_ITEM(item, j);
                        Variant v;
                        convert(ScriptOperation::VARIANT_TYPE,itemx,v);
                        variantVec.push_back(v);
                    }
                }
                variantVecMap[i] = variantVec;
            }
            else
            {
                convert(op_argtypes[i],item,v);
            }

            //std::cout << op_argnames[i] << " " << op_argtypes[i] << " " <<  v.ToJSON() << std::endl;

            variantArgs.push_back(v);
        }
    }

//    for(int i = 0; i < variantArgs.size(); ++i)
//    {
//        Variant v = variantArgs[i];
//        std::cout << v.ToJSON() << std::endl;
//    }

    ScriptArguments sargs;

    sargs.input = scriptFilter->GetInput();
    sargs.contract = scriptFilter->GetInput()->GetOriginatingSource()->GetGeneralContract();
    sargs.args = variantArgs;
    sargs.datamap = datamap;
    sargs.variantVector = variantVecMap;
    sargs.pythonFilter = scriptFilter->GetPythonEnvironment();

    if(op_resp == ScriptOperation::AVT_DATA_SET)
    {
//        avtDataset_p result;

//        if(!op->func(sargs, result))

//        {
//            std::cerr << "operation failed!" << std::endl;
//            Py_DECREF(c_api_object);
//            Py_DECREF(m);
//            return NULL;
//        }
//        avtDataTree_p tree = scriptFilter->GetDataTree(result);

//        int leaves = 0;
//        vtkDataSet** datasets = tree->GetAllLeaves(leaves);

//        //std::cout << leaves << std::endl;
//        if(leaves != -1)
//        {
//            PyObject* out = scriptFilter->GetPythonEnvironment()->WrapVTKObject(datasets[0],"vtkDataSet");
//            //std::cout << out << std::endl;

//            Py_DECREF(c_api_object);
//            Py_DECREF(m);

//            return out;
//        }
    }
    else if(op_resp == ScriptOperation::VTK_DATA_ARRAY)
    {
        vtkDataArray* dataarray;
        if(!op->func(sargs, dataarray))

        {
            std::cerr << name << ": constant operation failed!" << std::endl;
            Py_DECREF(c_api_object);
            Py_DECREF(m);
            return NULL;
        }

        std::cout << "dataArray: " << dataarray << std::endl;
        PyObject* output = scriptFilter->GetPythonEnvironment()->WrapVTKObject(dataarray, "vtkDataArray");
        std::cout << output << std::endl;
        return output;
    }
    else if(op_resp == ScriptOperation::VTK_DATASET)
    {
        vtkDataSet* dataset;
        if(!op->func(sargs, dataset))

        {
            std::cerr << name << ": constant operation failed!" << std::endl;
            Py_DECREF(c_api_object);
            Py_DECREF(m);
            return NULL;
        }

        PyObject* output = scriptFilter->GetPythonEnvironment()->WrapVTKObject(dataset, "vtkDataSet");
        return output;
    }
    else
    {
        Variant result;
        if(!op->func(sargs, result))

        {
            std::cerr << name << ": constant operation failed!" << std::endl;
            Py_DECREF(c_api_object);
            Py_DECREF(m);
            return NULL;
        }

        PyObject* output = NULL;
        /// convert result to PyObject

        if(result.Type() == Variant::BOOL_TYPE)
            output = PyBool_FromLong(result.AsBool());
        else if(result.Type() == Variant::CHAR_TYPE)
            output = PyString_FromStringAndSize(&result.AsChar(),1);
        else if(result.Type() == Variant::UNSIGNED_CHAR_TYPE)
            output = PyByteArray_FromStringAndSize(&result.AsChar(),1);
        else if(result.Type() == Variant::STRING_TYPE)
            output = PyString_FromString(result.AsString().c_str());
        else if(result.Type() == Variant::INT_TYPE)
            output = PyInt_FromLong(result.AsInt());
        else if(result.Type() == Variant::LONG_TYPE)
            output = PyLong_FromLong(result.AsLong());
        else if(result.Type() == Variant::FLOAT_TYPE)
            output = PyFloat_FromDouble(result.AsFloat());
        else if(result.Type() == Variant::DOUBLE_TYPE)
            output = PyFloat_FromDouble(result.AsDouble());

        return output;
    }

//    Py_INCREF(scriptArgs);
//    Py_DECREF(c_api_object);
//    Py_DECREF(m);

    Py_INCREF(Py_None);
    return Py_None;
}
