/*****************************************************************************
*
* Copyright (c) 2000 - 2012, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

#include "QvisScriptWindow.h"

#include <InstallationFunctions.h>
#include <ScriptAttributes.h>
#include <ViewerProxy.h>

#include <QCheckBox>
#include <QLabel>
#include <QLayout>
#include <QLineEdit>
#include <QSpinBox>
#include <QButtonGroup>
#include <QRadioButton>
#include <QvisColorTableButton.h>
#include <QvisOpacitySlider.h>
#include <QvisColorButton.h>
#include <QvisLineStyleWidget.h>
#include <QvisLineWidthWidget.h>
#include <QvisVariableButton.h>

#include <avtPythonFilterEnvironment.h>
#include <QvisScriptBuiltInFunctionsWidget.h>
#include <QvisScriptRWidget.h>
#include <QvisScriptPythonWidget.h>


#include "ui_Script.h"

#include <cstdio>
#include <string>

// ****************************************************************************
// Method: QvisScriptWindow::QvisScriptWindow
//
// Purpose: 
//   Constructor
//
// Note:       Autogenerated by xml2window.
//
// Programmer: xml2window
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

QvisScriptWindow::QvisScriptWindow(const int type,
                         ScriptAttributes *subj,
                         const QString &caption,
                         const QString &shortName,
                         QvisNotepadArea *notepad)
    : QvisOperatorWindow(type,subj, caption, shortName, notepad,false)
{
    atts = subj;

    /// move to another class that initializes..

    scripts.push_back(new QvisScriptBuiltinFunctionsWidget(this));
    scripts.push_back(new QvisScriptPythonWidget(this));
    scripts.push_back(new QvisScriptRWidget(this));

    for(int i = 0; i < scripts.size(); ++i)
        scriptMap[scripts.at(i)->GetName()] = scripts.at(i);

    form = new Ui::Form();
}


// ****************************************************************************
// Method: QvisScriptWindow::~QvisScriptWindow
//
// Purpose: 
//   Destructor
//
// Note:       Autogenerated by xml2window.
//
// Programmer: xml2window
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

QvisScriptWindow::~QvisScriptWindow()
{
}


// ****************************************************************************
// Method: QvisScriptWindow::CreateWindowContents
//
// Purpose: 
//   Creates the widgets for the window.
//
// Note:       Autogenerated by xml2window.
//
// Programmer: xml2window
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************
void
QvisScriptWindow::CreateWindowContents()
{
    QVBoxLayout *mainLayout = new QVBoxLayout(0);
    topLayout->addLayout(mainLayout);

    QWidget* widget = new QWidget();
    form->setupUi(widget);
    mainLayout->addWidget(widget);

    QVBoxLayout *childLayout = new QVBoxLayout(0);

    form->childWidget->setLayout(childLayout);

    for(int i = 0; i < scripts.size(); ++i)
        form->scriptType->addItem(scripts.at(i)->GetName());

    form->scriptWidget->widget(0)->setEnabled(false);
    form->scripts->setRootIsDecorated(false);
    form->scripts->header()->setVisible(false);

    resetWindow();

    connect(form->scripts,SIGNAL(clicked(QModelIndex)),this,SLOT(scriptSelected(QModelIndex)));
    connect(form->addScript,SIGNAL(clicked()),this,SLOT(addScript()));
    connect(form->removeScript,SIGNAL(clicked()),this,SLOT(removeScript()));
}


// ****************************************************************************
// Method: QvisScriptWindow::UpdateWindow
//
// Purpose: 
//   Updates the widgets in the window when the subject changes.
//
// Note:       Autogenerated by xml2window.
//
// Programmer: xml2window
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

void
QvisScriptWindow::UpdateWindow(bool doAll)
{
    std::cout << "update called" << std::endl;
    for(int i = 0; i < atts->NumAttributes(); ++i)
    {
        if(!doAll)
        {
            if(!atts->IsSelected(i))
            {
                continue;
            }
        }

        switch(i)
        {
        }
    }
}


// ****************************************************************************
// Method: QvisScriptWindow::GetCurrentValues
//
// Purpose: 
//   Gets values from certain widgets and stores them in the subject.
//
// Note:       Autogenerated by xml2window.
//
// Programmer: xml2window
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

void
QvisScriptWindow::GetCurrentValues(int which_widget)
{
    MapNode master;

//    MapNode scripts;
//    foreach(const scriptAtts& s, scriptContentsMap)
//        scripts[s.name] = s.contents;

//    master["scripts"] = scripts;

//    MapNode nodes;
//    foreach(const scriptAtts& s, scriptContentsMap)
//        scripts[s.name] = s.contents;

//    master["scripts"] = scripts;


    atts->SetScriptMap(master);
}


//
// Qt Slot functions
//
#include <QMessageBox>
void
QvisScriptWindow::addScript()
{
    QString name = form->scriptName->text();
    bool isExecutable = form->isScriptExecutable->isChecked();

    if(name.length() == 0)
    {
        QMessageBox::warning(this,"No Script Name...", "Please Enter a Script Name");
        return;
    }

    if(scriptContentsMap.contains(name))
    {
        QMessageBox::warning(this,"Script already exists..", "Please Enter a Unique Script Name");
        return;
    }

    if(form->scriptType->currentIndex() == -1)
    {
        QMessageBox::warning(this,"Type can't be empty", "Please select Appropriate Type");
        return;
    }

    scriptAtts s;
    s.name = name;
    s.isExecutable = isExecutable;
    s.type = form->scriptType->currentText();
    s.type_index = form->scriptType->currentIndex();

    scriptContentsMap[name] = s;

    int lastRow = form->scripts->model()->rowCount();
    form->scripts->model()->insertRow(lastRow);
    QModelIndex lastIndex = form->scripts->model()->index(lastRow,0);

    form->scripts->model()->setData(lastIndex, name);

    form->scriptWidget->widget(0)->setEnabled(true);
    showChildWidget(name);

    resetWindow();
}

void
QvisScriptWindow::resetWindow()
{
    form->isScriptExecutable->setChecked(false);
    form->scriptName->setText("");
    form->scriptType->setCurrentIndex(-1);
}
void
QvisScriptWindow::removeScript()
{
    QString name = form->scriptName->text();

    if(!scriptContentsMap.contains(name))
        return;

    int res = QMessageBox::warning(this,"Are you sure?", "Are you sure you would like to remove entry?",
                                   QMessageBox::Ok, QMessageBox::Cancel);
    if(res == QMessageBox::Rejected) return;

    scriptContentsMap.remove(name);

    QModelIndexList list = form->scripts->model()->match(form->scripts->model()->index(0,0),Qt::DisplayRole, name);

    for(int i = 0; i < list.size(); ++i)
       form->scripts->model()->removeRow(list.at(i).row(),list.at(i).parent());

    resetWindow();

    if(form->scripts->model()->rowCount() == 0)
        form->scriptWidget->widget(0)->setDisabled(true);
}

void
QvisScriptWindow::scriptSelected(const QModelIndex &index)
{
    QString name = index.data().toString();

    if(scriptContentsMap.contains(name))
        showChildWidget(name);
}


void
QvisScriptWindow::showChildWidget(const QString &name)
{
    scriptAtts atts = scriptContentsMap[name];

    QLayout* layout = form->childWidget->layout();

    QLayoutItem* item = layout->takeAt(0);
    if(item) item->widget()->setVisible(false);

    layout->addWidget(scriptMap[atts.type]->GetRenderWidget());

    form->isScriptExecutable->setChecked(atts.isExecutable);
    form->scriptName->setText(atts.name);


    form->scriptType->setCurrentIndex(atts.type_index);
}


